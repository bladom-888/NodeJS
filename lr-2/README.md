## Функція add()
Ця функція є функцією-фабрикою, яка створює функцію додавання з можливістю ланцюжка викликів. Кожний виклик повертає нову функцію додавання, яка може бути викликана з аргументом для додавання до суми.

### Приклад використання

    const result = add(1)(2)(3)(4)(5)();
    console.log(result); // Output: 15
У цьому прикладі ми викликаємо функцію add зі значенням 1, потім викликаємо отриману функцію зі значенням 2, і так далі. В кінці ми викликаємо отриману функцію без аргументу, що повертає фінальну суму 15. Ми можемо продовжити ланцюжок викликів, передавши інші значення або просто викликавши отриману функцію без аргументу, щоб отримати поточну суму.

Ця функція є корисним інструментом для створення ланцюжків викликів функцій зі змінними параметрами, такими як додавання, множення, або будь-яких інших операцій, де потрібно зберігати стан між викликами функції.

## Функція isAnagram()

Ця функція перевіряє, чи є два рядки анаграмами один одного. Анаграми - це рядки, що мають однакові символи, але в різному порядку.

### Параметри
str1 (string): Перший рядок, який потрібно порівняти.

str2 (string): Другий рядок, який потрібно порівняти.
### Повертає
boolean: Результат перевірки - true, якщо str1 та str2 є анаграмами, і false в іншому випадку.

### Використання

    const result = isAnagram('listen', 'silent');
    console.log(result); // true

    const result2 = isAnagram('hello', 'world');
    console.log(result2); // false

## Функція deepCopy()
Ця функція глибоко копіює об'єкт, переданий їй в параметрі obj, зберігаючи всі вкладені об'єкти та масиви в окремих областях пам'яті. Функція повертає новий об'єкт, який є точною копією вхідного об'єкта.

### Параметри

obj: Об'єкт, який потрібно скопіювати. Може бути будь-якого типу, крім null і undefined.

### Повертає

Новий об'єкт, який є глибокою копією вхідного об'єкта.

### Використання
    const obj1 = {
    a: 1,
    b: {
        c: 2,
        d: [3, 4]
    }
    };

    const obj2 = deepCopy(obj1);
    console.log(obj1 === obj2); // false, різні об'єкти в пам'яті
    console.log(obj1.b === obj2.b); // false, різні об'єкти в пам'яті

    obj1.a = 10;
    console.log(obj1.a); // 10
    console.log(obj2.a); // 1, значення не змінюється у скопійованому об'єкті

    obj1.b.c = 20;
    console.log(obj1.b.c); // 20
    console.log(obj2.b.c); // 2, значення не змінюється у скопійованому об'єкті

    obj1.b.d.push(5);
    console.log(obj1.b.d); // [3, 4, 5]
    console.log(obj2.b.d); // [3, 4], масиви відокремлені в пам'яті

## Функція cacheResult()
Ця функція приймає на вхід функцію func з визначеним типом Func, яка приймає довільну кількість числових аргументів та повертає числовий результат. Функція cacheResult повертає обгортку навколо вхідної функції func, яка кешує результати виконання func залежно від переданих аргументів.

### Параметри

func: Функція, яка буде кешуватися. Має мати тип Func.
### Повертає

Функцію з таким же типом Func, яка є обгорткою навколо вхідної функції func з можливістю кешування результатів виконання.
### Використання

    const calc = (a: number, b: number, c: number) => a + b + c;
    const wrappedCalc = cacheResult(calc);

    console.log(wrappedCalc(1, 2, 3)); // Вивід: 6 (підраховано)
    console.log(wrappedCalc(1, 2, 3)); // Вивід: 6 (з кешу)
    console.log(wrappedCalc(4, 5, 6)); // Вивід: 15 (підраховано)
    console.log(wrappedCalc(4, 5, 6)); // Вивід: 15 (з кешу)

## Результат виконання
![result](/images/result.jpeg)